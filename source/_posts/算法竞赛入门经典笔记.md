---
title: 算法竞赛入门经典笔记
---
## 算法竞赛入门经典笔记
记录一些学习过程中的琐碎的知识点
-- begin:2023.1.4

#### 第零章 杂七杂八知识点

* scanf() 比 cin 快，使用cin的话可能会超时

* ```set```集合的使用：
  * begin() 　　 返回set容器的第一个元素的 地址
    end() 　　　　 返回set容器的最后一个元素 **地址 **
    clear() 　　 删除set容器中的所有的元素
    empty() 　　　 判断set容器是否为空
    max_size() 　 返回set容器可能包含的元素最大个数
    size() 　　　　 返回当前set容器中的元素个数
    erase(it) 删除迭代器指针it处元素
    insert(a) 插入某个元素

* ```next_permutation```全排列函数，这个函数每运行一次就可以把数组排成下一个字典排数列；与之对应的是prev_permutation，即排出上一个字典序；

* ```x%2``` 可以在代码中写成更快的运算方式 ```x&1```

* 结构体在优先队列的优先级设置

* ```c++
  struct node
  {
  	string name;
  	int price;
  	//friend bool operator<(const node &f1,const node &f2) 
  	//建议使用上面的引用来提高效率 
  	friend bool operator<(node f1,node f2)	// friend不可以少
  	{
  		return f1.price<f2.price;
  	}
  };
  priority_queue<node> q;
  ```

* ```lower_bound( )```和```upper_bound( )```都是利用二分查找的方法在一个排好序的数组中进行查找的。在从小到大的排序数组中，

  ```lower_bound(begin,end,num)```：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。

  ```upper_bound(begin,end,num)```：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。

  在从大到小的排序数组中，重载```lower_bound()```和```upper_bound()```

  ```lower_bound(begin,end,num,greater<type>())```:从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。

  ```upper_bound(begin,end,num,greater<type>())```:从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。

* 二分答案：使用二分法枚举答案，并且在枚举时判断这个答案是否可行。使用二分需要满足两个条件，一是有界，二是单调。

* 生成[0,1]之间的随机数：```(double)rand() / RAND_MAX```

* ```nth_element(a,a+6,a+10); //在a中，找到 第七小 将其放到a[6]```

* ```multiset```是C++ STL里的一种容器，里面的元素按顺序排列，默认升序，并且不去重(这点和```set```是不同的)

* ```auto```是自动判断数据类型，只有C++14以上才支持

#### 第一章 程序入门设计

* 尽量使用````const````声明常数
* 取n的十位：```n/10%10```
* ```printf("%03d\n", num);```的含义
* 交换变量之异或运算(交换变量a和b的值)：```a^=b^=a^=b;```(看着好玩，不建议使用)
  
    > 关于这个异或运算能达到这种效果的解释：$a\bigoplus (b\bigoplus a)=b$
* C语言中0为假，其他为真
* C语言中的''短路''
* C语言标准：C99,C11,C89(ANSI C)
  
    > 在C99中，double的输出必须用```%f```，而输入需要用```%lf```，当时在C89和C++中都不必如此——输入和输出都可以用```%lf```。而```gets```则在C11中被移除了。
* ```\n```中n代表newline
* C语言中```int```类型"很有可能"最大为2147483647，即$2^{31}-1$(反正是32位嘛，有符号无符号自己算出来就行)，为什么是"很有可能"呢？因为C99只规定了```int```至少是16位，却没有规定具体值。但是C99同时也规定了一些固定长度的整数，例如```int32_t,uint32_t```
* 三角函数使用的是弧度

#### 第二章 循环结构程序设计
* 不拘一格地使用伪代码来思考和描述算法
* 浮点运算可能存在误差，在进行浮点数比较时，应考虑到浮点误差
* C99中```long long```的范围是$-2^{63}$到$2^{63}-1$，输出时使用```%lld```，但是在MinGW的gcc中，要把```%lld```改成```%I64d```，所以如果涉及```long long```的输入输出，常用C++的输入输出流或者自定义的输入输出方法。
* 要计算只包含加法、减法和乘法的整数表达式除以正整数n的余数，可以在每步计算之后对n取余，结果不变
* 可以使用```time.h```中的```clock()```函数获得程序的运行时间，该函数返回程序目前为止运行的时间，用这个时间除以常数```CLOCKS_PER_SEC```之后得到的值以秒为单位```printf("%f\n",(double)clock()/CLOCKS_PER_SEC)```。(当涉及到键盘输入的程序，键盘输入的时间也会包含在程序运行时间内)
* ```scanf()```函数返回值是成功输入的变量的个数
* 使用文件最简单的方法是使用输入输出重定向，只需在```main```函数的入口处加入以下两条语句：```freopen("input.txt", "r", stdin); freopen("output.txt", "w", stdout);```(使用了重定向之后不能同时读写文件和标准输入输出)
* 实现自动"删除"重定向语句
    ```c
    #define LOCAL       // 如果要删除重定向，只需要删除或注释掉该语句即可
    #include <stdio.h>
    int main()
    {
        #ifdef LOCAL
        freopen("input.txt", "r", stdin); 
        freopen("output.txt", "w", stdout);
        #endif
        ...
    }
    ```
* 不使用重定向实现文件的输入输出：
    ```c
    #include <stdio.h>
    int main()
    {
        FILE *fin, *fout;
        fin = fopen("data.in", "rb");
        fout = fopen("data.out", "wb");
        int x;
        while(fscanf(fin, "%d", &x) == 1)   // 输入改为使用fscanf()
        {
            ...
        }
        fprintf(fout, "%d", x);             // 输出改为使用fprintf()
        fclose(fin);                        // 别忘了fclose()
        fclose(fout);
    }
    ```
    * 如果要将上述程序改为标准输入输出，只需赋值```fin=stdin;fout=stdout;```即可，且不需要调用```fopen()```和```fclose()```
    * ```fopen("con","r")```也可以打开标准输入输出，但是这个方法是不可移植的，它在Linux下无效

* 当嵌套的两个代码块中有同名变量时，内层的变量会屏蔽外层变量，有时会引起十分隐蔽的错误

#### 第三章 数组和字符串
* 数组的声明放在main函数外可以定义得很大，放在main函数里面的话稍大一点就会内存溢出，比较大的数组尽量声明在main函数外
    ```c
    #include <stdio.h>
    int a[10000000];            // 放在main函数外不会报错
    int main()
    {
        int a[10000000];        // 放在main函数内会报错Segment Fault
        return 0;
    }
    ```
* 从数组a赋值k个元素到数组b：```memcpy(b,a,sizeof(int)*k);```；如果需要把数组a全部复制到数组b中：```memcpy(b,a,sizeof(a));```(使用```memcpy()```需要包含头文件```string.h```)。
* 将数组a清零：```memset(a,0,sizeof(a));```
* 语句```int tot = a[x=0][y=n-1] = 1;```的理解：赋值表达式的返回值为所赋的值的大小
* 在很多情况下，最好是在做一件事之前检查是不是可以做，而不要做完再后悔，因为"悔棋"往往比较麻烦
* 读入字符串：```char str[12]; scanf("%s", str);```(```scanf("%s", str);```遇到空白字符会停下来，比如如果键盘输入"hello world"，数组```str```中只会存储"hello")
* ```sprintf()```用于输出到字符串(要保证字符串足够大，可以容纳输出信息)：
    ```c
    char str[23];
    int x = 1;
    int y = 2;
    sprintf(str, "%d %d", x, y);
    ```
* 注意C语言中字符串以```\0```结果，使用字符串数组时要考虑到这个
* 字符串处理函数(需要引入string.h)：
    * ```strchr(char *str, char a)```用于在一个字符串中查找单个字符a
    * ```strlen(char *str)```用于获取字符串的实际长度
    * ```strcpy(char *a, char *b)```用于字符串赋值
    * ```strcmp(char *a, char *b)```用于字符串比较
    * ```strcat(char *a, char *b)```用于字符串连接
* 滥用"++"，"--"，"+="等可以修改变量值的运算符很容易带来隐蔽的错误，建议每条语句最多只用一次这种运算符，并且所修改的变量在整条语句中只出现一次：
    ```c
    int count = 0;
    count = count++;                                    // count的值依然为0
    count = ++count;                                    // count的值为1
    count = 0;
    printf("%d %d %d\n", count++, count++, count++);    // 输出结果为2 1 0
    ```
* 如果输入的字符串中含有空格、TAB等，此时无法直接使用```scanf()```从标准输入中获取这样的字符串。
    * 此时可以使用```fgetc(fin)```从打开的文件```fin```中读取一个字符，然后返回一个```int```值(这个值对应当前字符对应的ASCII码，要先检查其不是```EOF```后再转化为```char```类型)，如果文件结束，将返回一个特殊标记```EOF```。
    * 如果要从标准输入中读取一个字符，可以使用```getchar()```，它等价于```fgetc(stdin)```。
    * 如果要读取完整的一行，可以使用```fgets(buf, maxn, fin)```读取不超过```maxn-1```个字符，要保证```buf```能存放下一行的内容。当一个字符都没有读到时，```fgets```返回```NULL```。
    * ```gets(char *str)```存在缓冲区溢出漏洞，不推荐使用，在C11中被删除。
* 不同操作系统的换行符是不一样的：Windows是```\r```和```\n```，Linux是```\n```，MacOS是```\r```，如果在Windows下读取文件，```fgetc()```和```getchar()```会将```\r```吃掉，只剩下```\n```；如果在Linux下读取相同的文件，则会忠实地先读取```\r```，然后才是```\n```。
* 常量数组的使用：
    ```c
    #include <stdio.h>
    char s[] = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./"
    int main()
    {
        int i, c;
        while((c = getchar()) != EOF)
        {
            for (i = 1; s[i] && s[i] != c; i++);    // 使用常量数组方便使用特定的字符，如果常量数组按一定顺序定义，还能根据下标很方便地进行字符操作
            if(s[i]) putchar(s[i-1]);
            else putchar(c);
        }
        return 0;
    }
    ```
* 如果按字符串处理```char```数组，如果数组不是以```\0```结尾的话，使用字符串进行处理的话可能会涉及到缓冲区之外的内存。


#### 第四章 函数和递归
* 在算法竞赛中，请总让main函数返回0
* ```typedef struct{ double x, y; }Point;```：避免涉及到结构体的地方都需要写一个```struct```，这样就可以像使用原生数据类型一样使用这个自定义类型。
* 即使最终答案在所选择的数据类型范围之内，计算的中间结果仍然可能溢出。
* 建议把用来判断某事物是否具有某种特性的函数命名成"is_xxx"的形式，返回```int```值，非0表示真，0表示假。
* 编写函数时，应尽量保证该函数能对任何合法参数得到正确的结果。如若不然，应在显著位置标明函数的缺陷，以避免误用。
* ```++```的优先级高于```*```，所以```*a++```会被解释为```*(a++)```
* 以数组为参数调用函数时，实际上只有数组首地址传递给了函数，需要另加一个参数表示元素个数。因为在函数中，是无法用```sizeof()```来获取数组参数的大小的。
* ```void *```：万能指针，它可以通过强制类型转化变成任意类型的指针。
* ```const void *```：指向常数的万能指针，可以指向任意类型的值，但它指向的值必须是常量，在这种情况下，我们不能修改被指向的对象，但可以使指针指向其他对象。
* Segmentation Fault：段错误；Stack Overflow：栈溢出
* 在Linux中，栈大小是由系统命令ulimit指定的，```ulimit -a```显示当前栈大小，```ulimit -s 32768```将栈大小指定为32MB。在Windows中，栈大小是存储在可执行文件中的，使用gcc可以这样指定可执行文件的栈大小：```gcc -Wl, --stack=16777216```，这样栈大小就变为16MB
* 如果一个函数返回一个局部变量的地址，会出现一个```warning```，因为局部变量存储在栈中，函数执行完毕后局部变量就失效了。

#### 第五章 C++与STL入门
* C++中推荐使用头文件```<cstdio>```替换```<stdio.h>```，类似的，```<cstring>```替换```<string.h>```，```<cmath>```替换```<math.h>```，```<cctype>```替换```<ctype.h>```
* C++中的头文件：```<iostream>```提供了输入输出流，```<algorithm>```提供了一些常用的算法
* ```cin>>a```的含义是从标准输入中读取```a```，这条语句的返回值是"一个已经读取了```a```的新流"。```cin>>a>>b```表示先从标准输入中读取```a```，在从已经读取了```a```的新流中读取```b```
* C++流避免使用```%d```等占位符，但是缺点是运行太慢，很多竞赛题目明确要求"本题的输入量很大，请不要使用C++的流输入"
* ```using namespace std```，```namespace```是C++中的"名称空间"，用来缓解复杂程序的组织问题，比如不同文件定义了相同的函数，为了区分就需要将各自的函数写在各自的"名称空间"内。基于这样的考虑，头文件```<iostream>```和```<algorithm>```里定义的内容放在```std```名称空间里。如果代码和该名称空间的内容不重名，就可以用```using namespace std```的方法将```std```里的名字导入默认空间，这样就可以用```cin```代替```std::cin```，```max```代替```std::max```了。
* 声明数组时，数组的大小可以使用```const```声明的常数(这在C99中是不允许的)
* C++中新增了一个```bool```数据类型，用```true```和```false```分别表示真和假
* C++中新增了一个```string```数据类型，用来替换C语言中的数组(用户仍然可以使用字符数组当字符串)。C++中的```cin/cout```可以直接读写```string```类型，却不能读写字符数组，```string```类型还可以像整数那样进行加减。```find()```用于找出字符串中某个字符所在的下标，```substr()```用于取字符串的子串。
* 如果输入数据每行包含若干个以空格隔开的整数，使用C++代码可以很简单：
    ```c++
    #include<iostream>
    #include<string>
    #include<sstream>
    using namespace std;

    int main(){
        string line;                    // string类在<string>头文件中
        while (getline(cin, line)) {    // 类似fgets，但由于使用string类型，所以无须指定最大长度
            int sum = 0, x;
            stringstream ss(line);      // stringstream在<sstream>头文件中，创建了一个字符串流
            while(ss >> x) sum += x;
            cout << sum << "\n";
        }
        return 0;
    }
    ```
* 可以把```string```作为流进行读写，定义在```<sstream>```头文件中，但是使用```string```很慢，```sstream```更慢。
* C++中提供了一个"引用"(by reference)，在功能上比指针弱一些：
    ```c++
    #include<iostream>
    using namespace std;

    void swap(int &a, int &b){...}  // &符号代表引用
    int main(){
        int a, b;
        swap(a, b);                 // 使用时直接传入变量即可
    }
    ```
##### 结构体
* C++除了支持结构体```struct```之外，还支持类```class```，而且在```struct```里除了可以有变量之外还可以有函数。C++在定义```struct```时不再使用```typedef```。
* C++结构体的构造与使用：
    ```c++
    #include<iostream>
    using namespace std;

    struct Point {
        int x, y;
        Point(int x = 0, int y = 0):x(x),y(y) {}            
        /* 
        构造函数(ctor)，“=0”表示0为默认值，如果没有指明这两个参数，就按0处理，因此Point()相当于Point(0,0)。
        “:x(x),y(y)”表示把成员变量x初始化为参数x，成员变量y初始化为参数y，也可以写成：
        Point(int x = 0, int y = 0) { this->x = x; this->y = y;}
        */
        Point() {} //这里没有的话会报错
};
    
    Point operator + (const Point& A, const Point& B) {     // 定义+运算符
        return Point(A.x+B.x, A.y+B.y);
}
    
    ostream& operator << (ostream &out, const Point& p) {   // 定义<<运算符
        out << "(" << p.x << "," << p.y << ")";
        return out;
}
    
    int main()
    {
        Point a, b(1, 2);       // 默认参数和指定参数两种调用方式
        a.x = 3;
        cout << a+b << "\n";
        return 0;
    }
    ```
* C++中的结构体可以有多个，在声明变量时调用
* C++中的函数可以有默认值
##### 模板
* 模板：
    ```c++
    template<typename T>
    T sum(T* begin, T* end) {
        T *p = begin;
        T ans = 0;
        for(T *p = begin; p != end; p++)
            ans = ans + *p;
        return ans;
    }
    ```
  结构体和类也可以有模板：
    ```c++
    template<typename T>
    struct Point {
        T x, y;
        Point(T x = 0, T y = 0):x(x), y(y) {}
    }
    // 定义结构体的运算
    template<typename T>
    ostream& operator << (ostream &out, const Point<T>& p)
    {
        out << "(" << p.x << "," << p.y << ")";
        return out;
    }

    template<typename T>
    Point<T> operator + (const Point<T>& A, const Point<T>& B)
    {
        return Point<T>(A.x + B.x, A.y + B.y);
    }
    ```
##### STL
* STL是指C++的标准模板库(Standard Template Library)：
    * ```algorithm```头文件中的```sort```可以给任意对象排序，包括内置类型和自定义类型，前提是类型定义了```<```运算符。
    
      ```c++
      vector<int> pancakes;
      sort(pancakes.begin(), pancakes.end());
      ```
    
    * ```algorithm```头文件中的```lower_bound```用于查找大于或等于```x```的第一个位置。
    
    * ```algorithm```头文件中的```unique```可以去掉有序数组中的重复元素，必须在```sort```之后使用，且```unique```本身不会删除元素，它将重复的元素移到了后面。
    ###### vector
    * ```vector```是不定长数组，它把一些常用操作"封装"在了```vector```类型内部。例如，若```a```是一个```vector```，可以用```a.size()```读取它的大小，```a.resize()```改变大小，```a.push_back()```向尾部添加元素，```a.pop_back()```删除最后一个元素，```a.clear()```清空数组，```a.empty()```测试是否为空。
    * ```vector```是一个模板类，所以需要用```vector<int> a```这样的方式来声明。
    ###### 集合与映射
    * 与```vector```用法类似的还有```set```集合，```map```映射，二者都支持```insert```，```find```，```count```，```remove```等操作。
    * ```set<string>::iterator```中```iterator```的意思是迭代器，用法类似于指针。
    * ```map```就是从键(key)到值(value)的映射，像是数组的"高级版"。
    
    ###### 栈、队列与优先队列
    
    * STL的栈定义在头文件```<stack>```中，可以用```stack<int>s```的方式声明一个栈，使用```push()```和```pop()```实现元素的入栈和出栈操作，```top()```取栈顶元素但不删除。
    * STL的队列定义在头文件```<queue>```中，可以用```queue<int>s```的方式声明一个队列，用```push()```和```pop()```进行元素的入队和出队操作，```front()```取队首元素但不删除。
    * 优先队列是一种抽象数据类型(Abstract Data Type, ADT)，行为有些像队列，但先出队列的元素不是先进队列的元素，而是队列中优先级最高的元素，这样就可以允许类似于"急诊病人插队"这样的事情发生。
    * STL的优先队列也定义在头文件```<queue>```中，用```priority_queue<int>pq```来声明。这个```pq```是一个"越小的整数优先级越低的优先队列"。由于出队元素并不是最先进队的元素，出队的方法由```queue```的```front()```变为了```top()```。
    * 自定义类型也可以组成优先队列，但必须为每一个元素定义一个优先级，这个优先级并不需要确定的数字，只需要能比较大小即可。可以定义一个结构体```cmp```，重载```()```运算符，使其看上去像一个函数(在C++中，重载了```()```的类或结构体称为仿函数(functor))，然后用```priority_queue<int, vector<int>, cmp>pq```这样的方式定义：
        ```c++
        struct cmp{
            bool operator() (const int a, const int b) const {
                return a % 10 > b % 10;     // a优先级比b小时返回true
            }
        };
        ```
    * 对于一些常见的优先队列，STL提供了更为简单的定义方法，比如"越小的整数优先级越大的优先队列"可以写成```priority_queue<int, vector<int>, greater<int> >pq```，注意最后的两个```>```不要连在一起，否则可能会被编译器误认为是```>>```运算符。
    ###### 测试STL
    * 和自己的代码一样，库也是需要测试的。一方面是因为库也是人写的，也有可能有bug，另一方面是因为测试之后能你更好地了解库的用法和优缺点。
    * 测试时往往使用```assert(表达式)```，当表达式为假时强行终止程序，并给出错误提示。
    ###### 大整数类BigInteger
    * 见《算法入门经典》p124
* ```<cstdlib>```中的rand()可生成闭区间[0, RAND_MAX]内均匀分布的随机整数，其中```RAND_MAX```至少为32767。如果要生成更大的随机整数，在精度要求不太高的情况下可以用```rand()```的结果"放大"得到。
* 可以用```<cstdlib>```中的```srand()```函数初始化随机数种子，如果需要程序每次执行是使用一个不同的种子，可以用```<ctime>```中的```time(NULL)```为参数调用```srand()```，一般来说，只在程序执行的开头调用一次```srand()```。```time()```函数返回的是"秒数"，每秒才变化一次，如果程序运行的间隔较短，就可能使用同一个种子。
* 把```vector```作为参数或者返回值时，应尽量改成用引用方式传递参数，以避免不必要的值被复制。
    ```c++
    vector<int> fill_random_int(int cnt)
    {
        vector<int> v;
        for(int i = 0; i < cnt; i++)
            v.push_back(rand());
        return v;
    }   // 函数内的局部变量v中的元素需要逐个复制给调用者，而传引用的方式调用就避免了这些复制过程
    ```
* ```vector```，```set```，```map```都很快，其中```vector```的速度接近于数组。尽管如此，在一些对时间要求非常高的题目中，STL有时会成为性能瓶颈。
* 可以给结构体声明一些属于该结构体类型的静态成员变量，方法是袈裟个```static```修饰符。静态成员变量在结构体外部使用时要写成```结构体名::静态成员变量名```

#### 第六章 数据结构基础

##### 队列

* STL中的双端队列```deque```，它可以快速地在首尾两端进行插入和删除。

##### 栈

* 简单的表达式解析可以根据栈来完成

##### 链表

* 在数组中频繁移动元素是很低效的，如有可能，可以使用链表
* 为了方便起见，常常在链表的第一个元素之前放一个虚拟的结点，方便在第一个元素之前插入新元素等操作。
* 在双向链表这样的复杂链式结构中，往往会编写一些辅助函数用来设置链接关系。
* 如果数据结构上的某一个操作很耗时，有时可以用加标记的方式处理，而不需要真的执行那个操作。但同时，该数据结构的所有其他操作都要考虑这个标记(具体例子见《算法入门经典》p145)。
* 测试的任务就是检查一份代码是否正确。如果找到了错误，最好还能提供一个让它出错的数据；调试的任务就是找到错误原因并改正。改正一个错误之后有可能引入新的错误，因此调试和测试往往要交替进行。
* 测试数据结构程序的常用方法是对拍：写一个功能相同但速度较慢的建议版本，再写一个数据生成器，不停地对比快慢两个程序的输出。简易版本的代码越简单越好，因为重点不在效率，而在正确性。
* 数据的复杂性会大大影响调试的难度，因此在找到让程序出错的数据之后最好别急着调试，而应尝试简化数据，或者直接用更小的参数调用数据生成器，以找到更简单的错误数据。

##### 二叉树

* 如果要定义一棵二叉树，其左右子结点类型都是"指向结点类型的指针"。换句话说，如果结点的类型为```Node```，则其左右子结点的类型都是```Node *```。可以用```new```运算符申请空间并执行构造函数，如果返回值为```NULL```，说明空间不足，申请失败。
    ```c++
    struct Node{
        bool have_value;
        int v;
        Node *left, *right;
        Node(): have_value(false), left(NULL), right(NULL) {}
    };
    Node *root;
    ```
    
* 可以用队列的方式实现二叉树的遍历：初始时只有一个根结点，然后每次取出一个结点，就把它的左右结点(如果存在)放入队列。这个方法又叫做宽度优先遍历(Breadth-First Search, BFS)。

* 如果程序动态申请内存，请注意内存泄露。程序执行完毕后，操作系统会回收该程序申请的所有内存(包括泄露的)，所以在算法竞赛中内存泄露往往不会造成什么影响。但是，从专业素养的角度考虑，请对内存泄露保持警惕。

* 也可以用数组的方式来实现二叉树：用整数表示结点编号，```left[u]```和```right[u]```分别表示```u```的左右子结点的编号。

* 用数组的方式实现二叉树编程简单，容易调试，但仍需具体问题具体分析。例如，用指针直接访问比"数组+下标"的方式略快。因此有的选手喜欢用"结构体+指针"的方式处理动态数据结构，但在申请结点时仍然用这里的"动态化静态"的思想，把```newNode```函数写成：
    ```c++
    Node* newNode() {Node *u = &node[++cnt]; u->left = u->right = NULL;
     u -> have_value = false; return u;}
    ```
  其中```node[]```是动态申请的结构体数组。这样写的坏处在于"释放内存"很不方便。如果反复执行新建结点和删除结点，```cnt```会一直增加，但是用完的内存却无法重用。在大多数算法竞赛题目中，这并不会引起问题，但是也有一些对内存要求极高的题目，对内存的一点浪费就会引起"内存溢出"错误。常见的解决方法是写一个简单的内存池(memory pool)，具体来说就是维护一个空闲列表(free list)，初始时吧上述```node[]```中的所有元素的指针放到该列表中，如下所示：
    ```c++
    // 可以用静态数组配合空闲列表来实现一个简单的内存池。
    queue<Node*> freenodes;
    Node node[maxn];

    void init(){
        for(int i = 0; i < maxn; i++)
            freenodes.push(&node[i]);   // 初始化内存池
    }

    Node* newnode(){
        Node* u = freenodes.front();
        u->left = u -> right = NULL; u->have_value = false;
        freenodes.pop();
        return u;
    }

    void deleteNode(Node* u){
        freenodes.push(u);
    }
    ```

* 二叉树的递归遍历(深度优先遍历Depth-First Search, DFS)分为 先序遍历、中序遍历、后序遍历：

  > PreOrder(T) = T的根结点 + PreOrder(T的左子树) +PreOrder(T的右子树)
  > InOrder(T) = InOrder(T的左子树) + T的根结点 + InOrder(T的右子树)
  >
  > PostOrder(T) = PostOrder(T的左子树) +PostOrder(T的右子树) + T的根结点

* 给定二叉树的中序遍历和后序遍历，可以构造出这棵二叉树。方法是根据后序遍历找到树根，然后在中序遍历中找到树根，从而找出左右子树的结点列表，然后递归构造左右子树。

##### 图

* 图也有DFS遍历和BFS遍历，其中前者使用递归实现，后者使用队列实现。求多维数组连通块的过程也称为种子填充(floodfill)。
* 用BFS求最短路径
* 在Uva816题目中，由于"朝向"也起到了关键作用，所以需要用一个三元组$(r,c,dir)$表示"位于(r,c)，面朝dir"这个状态。
* 很多复杂的迷宫问题都可以转化为最短路问题，然后用BFS求解。在套用BFS框架之前，需要先搞清楚图中的"结点"包含哪些内容。
* 拓扑排序(topological sort)：如果图中存在有向环，则不存在拓扑排序，反之则存在。不包含有向环的有向图称为有向无环图(DAG)，可以用DFS求出有向无环图的拓扑排序，如果排序失败，说明该有向图存在有向环，不是DAG。
* 欧拉道路(eulerian path)：能否从无向图中的一个结点出发走出一条道路，**每条边**恰好经过一次，这样的路线称为欧拉道路，也可以形象地称为“一笔画”。
  * 如果一个无向图是连通的，且最多只有两个奇点(度数为奇数的点)，则一定存在欧拉道路：如果有两个奇点，则必须从其中一个奇点出发，另一个奇点终止；如果奇点不存在，则可以从任意点出发，最终一定会回到该点(称为欧拉回路)。
  
  * 类似的推理可以得到有向图的结论：最多只能有两个点的入度不等于出度，而且必须是其中一个点的出度恰好比入度大1(把它作为起点)，另一个的入度比出度大1(把它作为终点)，当然，在忽略边的方向后，图必须是连通的。
  
  * 根据连通性和度数可以判断出无向图和有向图是否存在欧拉道路和欧拉回路，可以用DFS构造欧拉回路和欧拉道路。
  
  * 打印欧拉道路(无向图)：
  
    ```c++
    void euler(int u){
        for(int v = 0; v < n; v++)
        {
    		if(G[u][v] && !vis[u][v])
            {
                vis[u][v] = vis[v][u] = 1;
                euler(v);
                printf("%d %d\", u, v);
            }
        }
    }
    ```
  
    将上述代码改成有向图：将```vis[u][v] = vis[v][u] = 1;```改为```vis[u][v] = 1```
* 

#### 第七章 暴力求解法

* 很多问题都可以暴力解决——把所有可能性都列举出来，即使使用暴力枚举，也需要分析问题，提高枚举的效率。

##### 简单枚举

##### 枚举排列

* (具体思想参考原书p184)：输入整数n，按字典序从小到大的顺序输出前n个数的所有排列

* 生成1~n的排列

  ```c++
  void print_permutation(序列A, 集合S)
  {
      if(S为空) 输出序列A;
      else 按照从小到大的顺序依次考虑S的每个元素v
      {
          print_permutation(在A末尾添加v后得到的新序列, S-{v})
      }
  }
  ```

* 生成可重集的排列

* 解答树（遇到递归的情况可以试着思考其解答树）

* 下一个排列

  C++的STL提供了一个库函数```next_premutation```

  ```c++
  #include <cstdio>
  #include <algorithm>
  using namespace std;
  int main()
  {
  	int n, p[10];
      scanf("%d", &n);
      for(int i = 0; i < n; i++) scanf("%d", &p[i]);
      sort(p, p+n);
      do{
          for(int i = 0; i < n; i++) printf("%d ", &p[i]);
      	printf("\n");
      }while(next_premutation(p, p+n));
      return 0;
  }
  ```

  从字典序最小排列开始，不停调用"求下一个排列"的过程。

* 枚举排列的常见方法有两种：一是递归枚举，二是用STL中的```next_premutation```

##### 子集生成

* 给定一个集合，枚举所有可能的子集(以下讨论的集合中没有重复元素)

* 增量构造法

  第一种思路是一次选出一个元素放到集合中：

  ```c++
  // 枚举集合{0,1,2,...,n-1}的子集
  void print_subset(int n, int* A, int cur)
  {
      for(int i = 0; i < cur; i++) printf("%d ", A[i]);	// 打印当前集合
      printf("\n");
      int s = cur ? A[cur-1]+1 : 0;						// 确定当前集合中的最小值
      for(int i = s; i < n; i++)
      {
          A[cur] = i;										// 一次选出一个元素放到集合中
          print_subset(n, A, cur+1);						// 递归构造子集
      }
  }
  // 当集合中元素个数为10时，解答树上有1024个结点
  ```

  在枚举子集的增量法中，需要使用**定序**的技巧：规定集合A中所有元素的编号从小到大排列，从而避免同一个集合枚举两次。

* 位向量法（有点像位图，用0和1代表当前元素有效或无效）

  第二种思路是构造一个位向量B[i]，而不是直接构造子集本身（其中B[i]=1，当且仅当i在子集中）

  ```c++
  void print_subset(int n, int* B, int cur)
  {
  	if(cur == n)
      {
          for(int i = 0; i < cur; i++)
  			if(B[i]) printf("%d ", i);		// 打印已选取的元素
          printf("\n");
          return;
      }
      B[cur] = 1;								// 选取第cur个元素
      print_subset(n, B, cur+1);
  	B[cur] = 0;								// 不选取第cur个元素
      print_subset(n, B, cur+1);
  }
  // 当集合中元素个数为10时，解答书上有2047个结点
  ```

* 二进制法（思想类似于位向量法，但通过二进制的性质简化了代码）

  用二进制来表示{0, 1, 2, ... , n-1}的子集S：从右往左第i位表示元素i是否在集合S中（示意图见书中p189）

  用二进制表示子集的好处：可以通过二进制的位运算实现常见的集合运算（&、|、^对应集合的交、并、对称差运算）

  ```c++
  void print_subset(int n, int s)			// 打印子集
  {
      for(int i = 0; i < n; i++)
          if(s&(1<<i)) printf("%d ", i);
      printf("\n");
  }
  // 枚举子集(和枚举整数一样简单)
  for(int i = 0; i < (1<<n); i++)
      print_subset(n, i);
  ```

##### 回溯法

* 直接枚举法的优点是思路和程序都很简单，确定点在于无法简便地减小枚举量——必须生成所有可能解，然后一一检查。回溯法的思路是在递归构造中，将生成和检查有机地结合起来，从而减少不必要的枚举。
* 当把问题分成若干步骤并递归求解时，如果当前步骤没有合法选择，则函数将返回上一级递归调用，这种现象成为回溯。正是这个原因，递归枚举算法常被称为回溯法，应用十分普遍。
* 八皇后问题：在棋盘上放置8个皇后，使得它们互不攻击，要求找出所有解。
  * 如果在回溯法中使用了辅助的全局变量，则一定要及时把它们恢复原状。特别地，若函数有多个出口，则需在每个出口处恢复被修改的值
* 如果最坏情况下的枚举量很大，应该使用回溯法而不是生成-测试法
* 在求最优解的问题中，应尽量考虑最优性剪枝。这往往需要记录下当前最优解，并且想办法“预测”一下从当前节点出发是否可以扩展到更好的方案。具体来说，先计算一下最理想情况可以得到怎样的解，如果连最理想情况都无法得到比当前最优解更好的方案，则剪枝。（经典例题：带宽BandWidth）

##### 路径寻找问题

* 很多问题都可以归结为图的遍历，但这些问题中的图却不是实现给定、从程序读入的，而是由程序动态生成的，成为隐式图。

* 回溯法一般是要找到一个或所有满足约束的解（或某种意义下的最优解），而状态空间搜索一般是要找到一个从初始状态到终止状态的路径。

* 路径寻找问题可以归结为隐式图的遍历，它的任务是找到一条从初始状态到终止状态的最优路径，而不是像回溯法那样找到一个符合某些要去的解。

* 八数码问题

  * 八数码问题可归纳为图上的最短路问题

    ```c++
    int goal[9];
    int s[9];
    memcpy(goal, s, sizeof(s))
    if(memcmp(goal, s, sizeof(s)) == 0) return ...;	
    ```

  * 使用```<cstring>```中的```memcmp```和```memcpy```完成整块内存的比较和复制，比用循环比较和循环复制要快。

  * 把书上的代码读一读，很有意思：

    ```c++
    typedef int State[9];										// 定义状态类型，这样定义可以简化二维数组的使用
    const int maxstate = 1000000;								// 最大状态数
    State st[maxstate], goal;									// 状态数组，所有状态都保存在这里
    int dist[maxstate];											// 距离数组，对应每个状态移动的步数
    // 如果需要打印方案，可以在这里加一个“父亲编号”数组 int fa[maxstate]
    
    const int dx[] = {-1, 1, 0, 0};
    const int dy[] = {0, 0, -1, 1};
    
    /*
    	bfs一般都用队列实现，这里的主要思想是：将当前状态的下一个可能状态放入对列中，
    	然后继续处理队列中下一个状态，直到最先出现目标状态，此时的移动步数最小。
    */
    int bfs()
    {
        init_lookup_table();									// 初始化查找表
        int front = 1, rear = 2;								// 不使用0下标，因为0被看作不存在
        while(front < rear) {
            State& s = st[front];								// 用“引用”简化代码
            if(memcmp(goal, s, sizeof(s)) == 0) return front;	// 找到目标状态并返回下标
            int z;
            for(z = 0; z < 9; z++) if(!s[z]) break;				// 找“0”位置
            int x = z/3, y = z%3;								// 获取行列编号(0~2)
            for(int d = 0; d < 4; d++) {
                int newx = x + dx[d];
                int newy = y + dy[d];
                int newz = newx * 3 + newy;
                if(newx >= 0 && newx < 3 && newy >= 0 && newy <3) {
                    State& t = st[rear];
                    memcpy(&t, &s, sizeof(s));
                    t[newz] = s[z];
                    t[z] = s[newz];
                    dist[rear] = dist[front] + 1;				// 更新当前状态移动步数
                    if(try_to_insert(rear)) rear++;				// 如果成功插入查找表，修改队尾指针
                }
            }
            front++;											// 扩展完毕修改队首指针
        }
        return 0;												// 失败，无解
    }
    
    int main()
    {
        for(int i = 0; i < 9; i++) scanf("%d", &st[1][i]);
        for(int i = 0; i < 9; i++) scanf("%d", &goal[i]);
        int ans = bfs();
        if(ans > 0) printf("%d\n", dist[ans]);
        else printf("-1\n");
        return 0;
    }
    ```

  * 使用BFS遍历图需要判重：

    * ~~直接声明一个9维数组：```vis[s[0]][s[1]][s[2]][s[3]]...[s[8]]```~~

    * 设计一套排列的编码（encoding）和解码（decoding）函数，把0-8的全排列和0-362879（9! = 362879）的整数一一对应，即将排列变成整数，然后只打开一个一维数组。

      ```c++
      int vis[362880], fact[9];
      void init_lookup_table(){
          fact[0] = 1;
          for(int i = 1; i < 9; i++) fact[i] = fact[i-1] * i;
      }
      int try_to_insert(int s){
          int code = 0;
          for(int i = 0; i < 9; i++){
              int cnt = 0;
              for(int j = i+1; i <9; i++) if(st[s][j] < st[s][i]) cnt++;
              code += fact[8-i] * cnt;
          }
          if(vis[code]) reutrn 0;
          return vis[code] = 1;
      }
      ```

      尽管原理巧妙，时间效率也非常高，但编码解码法的适用范围并不大：如果隐式图的总结点数非常大，编码也将会很大，数组还是开不下。

    * 使用哈希（hash）技术，使用哈希函数h(x)将任意结点映射到给定范围[0, M-1]的整数即可，在理想情况下只需要开一个大小为M的数组就能完成判重，此时需要将哈希值相同的状态组织成链表。

      ```c++
      const int hashsize = 1000003；
      int head[hashsize], next[maxstate];
      void init_lookup_table() { memset(head, 0, sizeof(head)); }
      int hash(State& s) {
          int v = 0;
          for(int i = 0; i < 9; i++) v = v * 10 + s[i];	// 把9个数字组合成9位数
          return v % hashsize;							// 确保hash值不超过hash表的大小
      }
      int try_to_insert(int s) {
          int h = hash(st[s]);
          int u = head[h];
          while(u) {
              if(memcmp(st[u], st[s], sizeof(st[s])) == 0) return 0;
              u = next[u];
          }
          next[s] = head[h];								// 用两个数组来实现链表，有意思
          head[h] = s;
          return 1;
      }
      ```

      哈希表的执行效率高，适用范围也很广。在哈希表中，对效率起到关键作用的是哈希函数，如果哈希函数选取得当，几乎不会有结点的哈希值相同，且此时链表查找的速度也较快；但如果冲突严重，整个哈希表会退化成少数几条长长的链表，查找的速度将非常缓慢。

    * 使用STL中的集合set。把状态转化成9位十进制整数，就可以用```set<int>```判重了

      ```c++
      set<int> vis;
      void init_lookup_table() { vis.clear(); }
      int try_to_insert(int s) {
          int v = 0;
          for(int i = 0; i < 9; i++) v = v * 10 + st[s][i];
          if(vis.count(v)) reutrn 0;
          vis.insert(v);
          return 1;
      }
      ```

      使用STL的代码最简单，但时间效率也最低（若此时不用O2优化则速度劣势更加明显）。建议在时间紧迫或者对效率要求不太高的情况下使用，或者仅把它作为”跳板”——先写一个STL程序，确保主算法正确，然后把set替换成自己写的哈希表。

* 倒水问题：倒水量最少不一定是步数最少！！！——>使用优先队列，倒水量少的结点先扩展（TODO）

##### 迭代加深搜索

* 埃及分数问题：这道题理论上可以用回溯法求解，但是该题的解答树非常恐怖——不仅深度没有明显的上界，而且在加数的选择在理论上也是无限的。如果采用宽度优先遍历，每一层都无限大，根本扩展不玩
* 解决方案是采用迭代加深搜索：从小到大枚举上限maxd，每次执行只考虑深度不超过maxd的结点。这样，只要解的深度有限，就一定能在有限时间内解出来。
* 对于可以用回溯法求解但解答树的深度没有明显上限的题目，可以考虑使用迭代加深搜索（iterative deepening）
* 如果可以设计出一个乐观估计函数，预测从当前结点至少还需要扩展基层结点才有可能得到解，则迭代加深搜索变成了IDA*算法

#### 第八章 高效算法设计

##### 算法分析初步

* 渐进时间复杂度
* 统计程序中“基本操作”的数量，可以排除机器速度的影响，衡量算法本身的优劣程度。基本操作的数量往往可以写成关于“输入规模“的表达式，保留最大项并忽略系数后的简单表达式称为算法的渐进时间复杂度，用于衡量算法中基本操作数随规模的增长情况。
* 上界分析：在算法设计中，常常不进行精确分析，而是假定各种最坏情况同时渠道，得到上界。在很多情况下，这个上界和实际情况同阶（称为紧的上界），但也有可能会因为分析方法不够好，得到松的上界。松的上界也是正确的上界，但是会让人错误地估计程序的实际运行时间。
* 分治法：
  * 划分问题：把问题的实例划分为子问题
  * 递归求解：递归解决子问题
  * 合并问题：合并子问题的解得到原问题
* 渐进时间复杂为多项式的算法称为多项式时间算法（polymonial-time algorithm），也称为有效算法；而$n!$或者$2^n$这样的低效的算法称为指数时间算法（exponential-time algorithm）。
* 上界分析的结果在趋势上能反映算法的效率，但有两个不精确性：一是公式本身的不精确性。例如非主流基本操作的影响、隐藏在大$O$记号后的低次项和最高项系数；二是对程序实现细节与计算机硬件的依赖性。
* 多数算法竞赛题目所选取的数据规模基本符合：$n\leq8$的题目，可能$n!$的算法已经足够，$n\leq20$的题目需要用到$2^n$的算法，而$n\leq300$的题目可能必须用至少$n^3$的多项式时间算法了。

##### 排序与检索

* 归并排序$O(nlogn)$：

  * 步骤：
    * 划分问题：把序列分成元素个数尽量相等的两半
    * 递归求解：把两半元素分别排序
    * 合并问题：把两个有序表合并成一个
  * 用归并排序解决逆序对问题

* 快速排序（最坏情况：$O(n^2)$；平均情况：$O(nlogn)$）：

  * 快速排序是最快的通用内部排序算法，相对归并排序来说不仅速度更快，并且不需要辅助空间。在实际情况下几乎不可能达到最坏情况，效率非常高。
  * 步骤：
    * 划分问题：把数组的各个元素重排后分成左右两部分，使得左边的任意元素都小于或等于右边的任意元素。
    * 递归求解：把左右两部分分别排序。
    * 合并问题：不用合并，因为此时数组已经完全有序。
  * 实际上，快速排序有多种实现方法，“划分过程”有多种不同的方法导致快速排序有不同的版本。
  * 快速选择问题：使用快速排序，并由于每个部分都是有序的且整个部分也是有序的，可以根据每个部分的首尾元素快速判断目标元素再哪个组。根据这个思想，可以在平均$O(n)$时间内选出数组中第k大的元素。

* 二分查找（$O(logn)$）：

  * 二分查找一般写成非递归形式

    ```c++
    int bsearch(int* A, int x, int y, int v){
        int m;
        while(x < y){
            m = x+(y-x)/2;
            if(A[m] == v) return m;
            else if(A[m] > v) y = m;
            else x = m + 1;
        }
        return -1;
    }
    ```

##### 递归与分治

* 棋盘覆盖问题
* 循环日程表问题
* 巨人与鬼问题（极角扫描法）

##### 贪心法

* 注意贪心法的使用和正确性证明（贪心选择性质和最优子结构性质）
* 背包问题：
  * 最优装载问题
  * 部分背包问题
  * 乘船问题
* 区间相关问题：
  * 选择不相交区间
  * 区间选点问题
  * 区间覆盖问题
  
* Huffman编码：
  * 最优编码问题

##### 算法设计与优化策略

* 构造法：很多时候可以通过”直接构造解“的方法来解决问题。

#### 第九章 动态规划初步

* 动态规划的理论性和实践性都比较强，一方面需要理解“状态”、“状态转移”、“最优子结构”、“重叠子问题”等概念，另一方面又需要根据题目的条件灵活设计算法。可以这样说，对动态规划的掌握情况在很大程度上能直接影响一个选手的分析和建模能力。
* 动态规划是一种用途很广的问题求解方法，它本身并不是一个特定的算法，而是一种思想，一种手段。
* 动态规划的核心是状态和状态转移方程，所有动态规划问题都可以归纳成有向无环图的求解。
* 有了状态转移方程后：
  * 递归计算
    * 用直接递归的方法计算状态转移方程，效率往往十分地下。其原因是相同的子问题被重复计算了很多次。
  * 递推计算（逆序枚举）
    * 可以用递推法计算状态转移方程。递推的关键是边界和计算顺序。在多数情况下，递推法的时间复杂度是：状态总数$\times$每个状态的决策个数$\times$决策时间。如果不同状态的决策个数不同，需要具体问题具体分析。
  * 记忆化搜索
    * 用状态数组判断某个结点是否已经计算
    * 可以用记忆化搜索的方法计算状态转移方程。当采用记忆化搜索时，不必事先确定各状态的计算顺序，但需要记录每个状态“是否已经计算过”。

##### 有向无环图上的动态规划

* 有向无环图DAG（Directed Acyclic Graph）上的动态规划是学习动态规划的基础，很多问题都可以转化为DAG上的最长路、最短路或者路径计数问题。
* DAG模型：
  * 嵌套矩形问题：
    * 矩形之间可嵌套的关系是一个典型的二元关系，二元关系可以用图来建模。如果矩形X可以嵌套在矩形Y里，就从X到Y连一条有向边。这个图是无环的，因为矩形无法直接或间接嵌套在自己内部。
    * 最长路及其字典序：
      * 在记忆化搜索中，可以为正在处理的表项声明一个引用，简化对它的读写操作。比如```int& ans = d[i][j][k][l][m][n]```
      * 设d(i)表示从结点i出发的最长路长度，可以求出最优值，并且可以通过递归打印出字典序最小的方案，但是如果设d(i)表示以结点i为终点的最长路径长度，虽然也能求出最优值，却难以打印出字典序最小的方案。
  * 硬币问题：
    * 本题的本质上也是DAG上的路径问题，将每种面值看作一个点，表示“还需要凑足的面值”，则初始状态为S，目标状态为0，若当前在状态i，每使用一个硬币j，状态便转移到i-Vj。
    * 固定终点的最长路和最短路：
      * 当程序需要用到特殊值时，应确保该值在正常情况下不会被取到。这不仅意味着特殊值不能有“正常的理解方式”，而且也不能在正常运算中“意外得到”。
      * 在记忆化搜索中，如果用特殊值表示“还没算过”，则必须将其和其他特殊值（如无解）区分开。
      * 在记忆化搜索中，可以用vis数组记录每个状态是否计算过，以占用一些内存为代价增强程序的可读性，同时减少出错的可能。
      * 如果状态比较复杂，推荐用STL中的```map```而不是普通数组保存状态值。这样，判断状态S是否算过只需用```if(d.count(S))```即可。
* 数组作为指针传递时，不会复制数组中的数据，因此不必担心这样会带来不必要的时间开销。
* 传统的递推法可以表示成“对于每个状态i，计算f(i)”，或者称为“填表法”。这需要对于每个状态i，找到f(i)依赖的所有状态，在某些时候并不方便。另一种方法是“对于每个状态i，更新f(i)所影响到的状态“，或者称为”刷表法“，有时比填表法方便。但需要注意的是，只有当每个状态所依赖的状态对它的影响互相独立时才能用刷表法。

##### 多阶段决策问题

* 多阶段决策的最优化问题往往可以用动态规划解决，其中，状态及其转移类似于回溯法中的解答树。解答树中的“层数”，也就是递归函数中的“当前填充位置”cur，描述的是即将完成的决策序号，在动态规划中被称为“阶段”。
* 最好不要用变量定义一个数组，不然容易RUNTIME ERROR!!!



#### 第十一章 图论模型与算法

##### 树

* 无根树转有根树：把“目标根结点”的相邻结点的父结点（相邻结点通过邻接矩阵判断）都设为该结点，然后依次递归。

* 表达式树：（艹，编译原理）

* 最小生成树
  
  * Kruskal算法
    * 并查集详解：https://www.luogu.com.cn/blog/tbr-blog/solution-p3367
  
  * Prim算法
  
* 最短路问题：

  * Dijkstra算法

  * Bellman-Ford算法

  * Floyd算法

    ```c++
    for(int k = 0; k < n; k++)
        for(int i = 0; i < n; i++)
            for(int j = 0; j < n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
    ```

    